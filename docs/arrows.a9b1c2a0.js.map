{"mappings":"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","sources":["src/arrows/Vector.ts","src/arrows/sketch.ts","/home/ajaska/other/experiments/node_modules/@parcel/scope-hoisting/lib/helpers.js","src/arrows/index.ts"],"names":["sumR","total","current","Point","constructor","x","y","z","isNaN","Error","this","[object Object]","points","avgX","map","p","reduce","length","avgY","avgZ","toPoint","Vector","Math","sqrt","atan2","add","v","r","cos","theta","sin","distance","PI","angle","unit","vs","divide","n","multiply","limit","clone","GoalType","MAX_TURN_SPEED","flyToCenterOfFlock","_boid","flock","flockCenter","$b83df0b36512c37c6e31d49efae33a72$export$Point","averageOfPoints","f","type","goal","maintainDistance","boid","vectors","flockMate","direction","push","Acceleration","$b83df0b36512c37c6e31d49efae33a72$export$Vector","sumVectors","matchVelocity","flockVelocity","Velocity","center","X_DIM","Y_DIM","stayInBounds","lerped","scaled","MAX_ANGLE_DIFF","PI_2","normAngle","computeSteer","desired","acceleration","velocity","newBoidVector","state","boids","filter","someBoid","id","otherBoid","vector","angleDiff","abs","isNeighbor","MAX_ACCEL","mouse","p5","mouseX","mouseY","moveTowardsMouse","updateState","dv","newV","dAngle","limitMaxTurnSpeed","point","forceInBounds","drawBoid","sketch","radians","translate","rotate","beginShape","vertex","scale","endShape","CLOSE","pop","a","__esModule","default","setup","createCanvas","frameRate","randomSeed","i","random","undefined","$cc0d678a26a9a61574c485073b91de$export$setup","draw","$cc0d678a26a9a61574c485073b91de$export$updateState","background","fill","circle","max","color","frameCount","floor","stroke","$cc0d678a26a9a61574c485073b91de$export$draw","document","getElementById"],"version":3,"file":"arrows.a9b1c2a0.js.map","sourcesContent":["// Based off of https://github.com/evanw/lightgl.js/blob/master/src/vector.js\n\nconst sumR = (total: number, current: number) => total + current;\n\nexport class Point {\n  x: number;\n  y: number;\n  z: number;\n\n  constructor(x: number, y: number, z?: number) {\n    if (isNaN(x) || isNaN(y) || isNaN(z || 0)) {\n      throw new Error(\"Point cannot have NaN\");\n    }\n\n    this.x = x;\n    this.y = y;\n    // this.z = z || 0;\n    this.z = 0;\n  }\n\n  static averageOfPoints(points: Point[]) {\n    const avgX = points.map((p) => p.x).reduce(sumR, 0) / points.length;\n    const avgY = points.map((p) => p.y).reduce(sumR, 0) / points.length;\n    const avgZ = points.map((p) => p.z).reduce(sumR, 0) / points.length;\n\n    return new Point(avgX, avgY, avgZ);\n  }\n\n  toPoint(p: Point): Vector {\n    const x = p.x - this.x;\n    const y = p.y - this.y;\n    return new Vector(Math.sqrt(x * x + y * y), Math.atan2(y, x));\n  }\n\n  add(v: Vector): Point {\n    return new Point(\n      this.x + v.r * Math.cos(v.theta),\n      this.y + v.r * Math.sin(v.theta)\n    );\n  }\n\n  // toPoint(p: Point): Vector {\n  //   // return new Vector(p.x - this.x, p.y - this.y, p.z - this.z);\n  //   return new Vector(p.x - this.x, p.y - this.y, p.z - this.z);\n  // }\n\n  // add(v: Vector) {\n  //   return new Point(this.x + v.x, this.y + v.y, this.z + v.z);\n  // }\n\n  distance(p: Point): number {\n    return this.toPoint(p).length();\n  }\n}\n\nexport class Vector {\n  r: number;\n  theta: number;\n\n  constructor(r: number, theta: number) {\n    this.r = r;\n\n    while (theta > Math.PI) theta -= Math.PI * 2;\n    while (theta < -Math.PI) theta += Math.PI * 2;\n    this.theta = theta;\n  }\n\n  length() {\n    return this.r;\n  }\n\n  angle() {\n    return this.theta;\n  }\n\n  unit() {\n    return new Vector(1, this.theta);\n  }\n\n  // https://math.stackexchange.com/questions/1365622/adding-two-polar-vectors\n  static sumVectors(vs: Vector[]) {\n    let x = 0;\n    let y = 0;\n    for (const v of vs) {\n      x += v.r * Math.cos(v.theta);\n      y += v.r * Math.sin(v.theta);\n    }\n    return new Vector(Math.sqrt(x * x + y * y), Math.atan2(y, x));\n  }\n\n  divide(n: number) {\n    return new Vector(this.r / n, this.theta);\n  }\n\n  multiply(n: number) {\n    return new Vector(this.r * n, this.theta);\n  }\n\n  limit(n: number) {\n    if (this.r < n) {\n      return this.clone();\n    }\n    return new Vector(n, this.theta);\n  }\n\n  clone() {\n    return new Vector(this.r, this.theta);\n  }\n}\n\n// Provides a simple 3D vector class. Vector operations can be done using member\n// functions, which return new vectors, or static functions, which reuse\n// existing vectors to avoid generating garbage.\nexport class Vector2D {\n  x: number;\n  y: number;\n  z: number;\n\n  _length?: number;\n  _unit?: Vector2D;\n  _angle?: number;\n\n  constructor(x: number, y: number, z?: number) {\n    if (isNaN(x) || isNaN(y) || isNaN(z || 0)) {\n      throw new Error(\"Vector2D cannot have NaN\");\n    }\n\n    this.x = x;\n    this.y = y;\n    // this.z = z || 0;\n    this.z = 0;\n  }\n\n  // ### Instance Methods\n  // The methods `add()`, `subtract()`, `multiply()`, and `divide()` can all\n  // take either a vector or a number as an argument.\n  negative() {\n    return new Vector2D(-this.x, -this.y, -this.z);\n  }\n\n  add(v: Vector2D | number) {\n    if (v instanceof Vector2D)\n      return new Vector2D(this.x + v.x, this.y + v.y, this.z + v.z);\n    else return new Vector2D(this.x + v, this.y + v, this.z + v);\n  }\n\n  subtract(v: Vector2D | number) {\n    if (v instanceof Vector2D)\n      return new Vector2D(this.x - v.x, this.y - v.y, this.z - v.z);\n    else return new Vector2D(this.x - v, this.y - v, this.z - v);\n  }\n\n  multiply(v: Vector2D | number) {\n    if (v instanceof Vector2D)\n      return new Vector2D(this.x * v.x, this.y * v.y, this.z * v.z);\n    else return new Vector2D(this.x * v, this.y * v, this.z * v);\n  }\n\n  divide(v: Vector2D | number) {\n    if (v instanceof Vector2D)\n      return new Vector2D(this.x / v.x, this.y / v.y, this.z / v.z);\n    else return new Vector2D(this.x / v, this.y / v, this.z / v);\n  }\n\n  equals(v: Vector2D) {\n    return this.x == v.x && this.y == v.y && this.z == v.z;\n  }\n\n  dot(v: Vector2D) {\n    return this.x * v.x + this.y * v.y + this.z * v.z;\n  }\n\n  cross(v: Vector2D) {\n    return new Vector2D(\n      this.y * v.z - this.z * v.y,\n      this.z * v.x - this.x * v.z,\n      this.x * v.y - this.y * v.x\n    );\n  }\n\n  length() {\n    return this._length || (this._length = Math.sqrt(this.dot(this)));\n  }\n\n  unit() {\n    return this._unit || (this._unit = this.divide(this.length()));\n  }\n\n  // 2d-angle\n  angle() {\n    return this._angle || (this._angle = Math.atan2(this.y, this.x));\n  }\n\n  limit(n: number) {\n    if (this.length() > n) {\n      return this.unit().multiply(n);\n    }\n    return this.clone();\n  }\n\n  min() {\n    return Math.min(Math.min(this.x, this.y), this.z);\n  }\n\n  max() {\n    return Math.max(Math.max(this.x, this.y), this.z);\n  }\n\n  toAngles() {\n    return {\n      theta: Math.atan2(this.z, this.x),\n      phi: Math.asin(this.y / this.length()),\n    };\n  }\n\n  angleTo(a: Vector2D) {\n    return Math.acos(this.dot(a) / (this.length() * a.length()));\n  }\n\n  toArray(n: number) {\n    return [this.x, this.y, this.z].slice(0, n || 3);\n  }\n\n  clone() {\n    return new Vector2D(this.x, this.y, this.z);\n  }\n\n  static fromAngles(theta: number, phi: number) {\n    return new Vector2D(\n      Math.cos(theta) * Math.cos(phi),\n      Math.sin(phi),\n      Math.sin(theta) * Math.cos(phi)\n    );\n  }\n\n  static averageOfVector2Ds(vectors: Vector2D[]) {\n    const avgX = vectors.map((p) => p.x).reduce(sumR, 0) / vectors.length;\n    const avgY = vectors.map((p) => p.y).reduce(sumR, 0) / vectors.length;\n    const avgZ = vectors.map((p) => p.z).reduce(sumR, 0) / vectors.length;\n\n    return new Vector2D(avgX, avgY, avgZ);\n  }\n}\n\n// ### Static Methods\n// `Vector.randomDirection()` returns a vector with a length of 1 and a\n// statistically uniform direction. `Vector.lerp()` performs linear\n// interpolation between two vectors.\n\n// Vector.negative = function (a, b) {\n//   b.x = -a.x;\n//   b.y = -a.y;\n//   b.z = -a.z;\n//   return b;\n// };\n// Vector.add = function (a, b, c) {\n//   if (b instanceof Vector) {\n//     c.x = a.x + b.x;\n//     c.y = a.y + b.y;\n//     c.z = a.z + b.z;\n//   } else {\n//     c.x = a.x + b;\n//     c.y = a.y + b;\n//     c.z = a.z + b;\n//   }\n//   return c;\n// };\n// Vector.subtract = function (a, b, c) {\n//   if (b instanceof Vector) {\n//     c.x = a.x - b.x;\n//     c.y = a.y - b.y;\n//     c.z = a.z - b.z;\n//   } else {\n//     c.x = a.x - b;\n//     c.y = a.y - b;\n//     c.z = a.z - b;\n//   }\n//   return c;\n// };\n// Vector.multiply = function (a, b, c) {\n//   if (b instanceof Vector) {\n//     c.x = a.x * b.x;\n//     c.y = a.y * b.y;\n//     c.z = a.z * b.z;\n//   } else {\n//     c.x = a.x * b;\n//     c.y = a.y * b;\n//     c.z = a.z * b;\n//   }\n//   return c;\n// };\n// Vector.divide = function (a, b, c) {\n//   if (b instanceof Vector) {\n//     c.x = a.x / b.x;\n//     c.y = a.y / b.y;\n//     c.z = a.z / b.z;\n//   } else {\n//     c.x = a.x / b;\n//     c.y = a.y / b;\n//     c.z = a.z / b;\n//   }\n//   return c;\n// };\n// Vector.cross = function (a, b, c) {\n//   c.x = a.y * b.z - a.z * b.y;\n//   c.y = a.z * b.x - a.x * b.z;\n//   c.z = a.x * b.y - a.y * b.x;\n//   return c;\n// };\n// Vector.unit = function (a, b) {\n//   var length = a.length();\n//   b.x = a.x / length;\n//   b.y = a.y / length;\n//   b.z = a.z / length;\n//   return b;\n// };\n// Vector.fromAngles = function (theta, phi) {\n//   return new Vector(\n//     Math.cos(theta) * Math.cos(phi),\n//     Math.sin(phi),\n//     Math.sin(theta) * Math.cos(phi)\n//   );\n// };\n// Vector.randomDirection = function () {\n//   return Vector.fromAngles(\n//     Math.random() * Math.PI * 2,\n//     Math.asin(Math.random() * 2 - 1)\n//   );\n// };\n// Vector.min = function (a, b) {\n//   return new Vector(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.min(a.z, b.z));\n// };\n// Vector.max = function (a, b) {\n//   return new Vector(Math.max(a.x, b.x), Math.max(a.y, b.y), Math.max(a.z, b.z));\n// };\n// Vector.lerp = function (a, b, fraction) {\n//   return b.subtract(a).multiply(fraction).add(a);\n// };\n// Vector.fromArray = function (a) {\n//   return new Vector(a[0], a[1], a[2]);\n// };\n// Vector.angleBetween = function (a, b) {\n//   return a.angleTo(b);\n// };\n","import p5 from \"p5\";\n\nimport { Vector, Point } from \"./Vector\";\n\ninterface Boid {\n  id: number;\n\n  p: Point;\n  v: Vector;\n}\n\nexport interface State {\n  boids: Boid[];\n\n  p5: p5;\n}\n\nenum GoalType {\n  Point = 1,\n  Velocity,\n  Acceleration,\n}\n\ninterface SeekPoint {\n  type: GoalType.Point;\n  goal: Point;\n}\n\ninterface MatchVelocity {\n  type: GoalType.Velocity;\n  goal: Vector;\n}\n\ninterface ApplyForce {\n  type: GoalType.Acceleration;\n  goal: Vector;\n}\n\ntype Goal = SeekPoint | MatchVelocity | ApplyForce | null;\n\nconst FLOCK_THRESHOLD = 50;\nconst SEPARATION_THRESHOLD = 25;\n\nconst MAX_SPEED = 3;\nconst MAX_ACCEL = 0.05;\n// 5 degrees\nlet MAX_TURN_SPEED = Math.PI / 36;\n\nconst X_DIM = 800;\nconst Y_DIM = 800;\nconst FRAME_RATE = 60;\n\nexport function setup(sketch: p5): State {\n  const RANDOM_SEED = 3;\n  const NUM_BOIDS = 200;\n\n  sketch.createCanvas(X_DIM, Y_DIM);\n  sketch.frameRate(FRAME_RATE);\n\n  sketch.randomSeed(RANDOM_SEED);\n  const boids: Boid[] = [];\n  // Old-school for-loop wow\n  for (let i = 0; i < NUM_BOIDS; i++) {\n    boids.push({\n      id: i,\n      p: new Point(sketch.random(0, X_DIM), sketch.random(0, Y_DIM)),\n      v: new Vector(sketch.random(0, 1), sketch.random(0, 2 * Math.PI)),\n    });\n  }\n\n  return { boids, p5: undefined } as any;\n}\n\n// Cohesion\n// Return: a vector with your new desired velocity\nfunction flyToCenterOfFlock(_boid: Boid, flock: Boid[]): Goal {\n  const flockCenter = Point.averageOfPoints(flock.map((f) => f.p));\n  return { type: GoalType.Point, goal: flockCenter };\n}\n\n// Separation\nfunction maintainDistance(boid: Boid, flock: Boid[]): Goal {\n  let vectors = [];\n\n  for (const flockMate of flock) {\n    // This is the direction away from the neighbor\n    let direction = flockMate.p.toPoint(boid.p);\n\n    const distance = direction.length();\n    if (distance > 0 && distance < SEPARATION_THRESHOLD) {\n      // The closer they are, the more we need to avoid them.\n      direction = direction.unit().divide(distance);\n      vectors.push(direction);\n    }\n  }\n\n  // If no one else is around, keep on keeping on\n  if (vectors.length === 0) return null;\n\n  return {\n    type: GoalType.Acceleration,\n    goal: Vector.sumVectors(vectors)\n      .divide(vectors.length)\n      .unit()\n      .multiply(MAX_ACCEL / 1.5),\n  };\n}\n\n// Alignment\nfunction matchVelocity(_boid: Boid, flock: Boid[]): Goal {\n  const flockVelocity = Vector.sumVectors(flock.map((f) => f.v)).divide(\n    flock.length\n  );\n\n  return { type: GoalType.Velocity, goal: flockVelocity };\n}\n\nconst center = new Point(X_DIM / 2, Y_DIM / 2);\nfunction stayInBounds(boid: Boid): Goal {\n  const threshold = X_DIM / 4;\n  const distance = center.distance(boid.p);\n  if (distance > threshold) {\n    const direction = boid.p.toPoint(center).unit();\n    const maxForceAt = X_DIM * (3 / 8);\n    const lerped = (distance - threshold) / (maxForceAt - threshold);\n    const scaled = direction.multiply(lerped).multiply(MAX_ACCEL);\n\n    return { type: GoalType.Acceleration, goal: scaled };\n  }\n  return null;\n}\n\nfunction forceInBounds(point: Point): Point {\n  const direction = center.toPoint(point);\n  if (direction.length() > X_DIM / 2) {\n    return center.add(direction.limit(X_DIM / 2));\n  }\n  return point;\n}\n\n// Return: a vector with your new desired velocity\nfunction moveTowardsMouse(mouse: Point, boid: Boid): Goal {\n  if (mouse.x > 0 && mouse.x < X_DIM && mouse.y > 0 && mouse.y < Y_DIM) {\n    const vector = boid.p.toPoint(mouse);\n    if (vector.length() < X_DIM / 6) {\n      return { type: GoalType.Point, goal: mouse };\n    }\n  }\n  return null;\n}\n\nconst MAX_ANGLE_DIFF = (Math.PI * 3) / 4;\nconst PI_2 = 2 * Math.PI;\nfunction isNeighbor(boid: Boid, otherBoid: Boid): boolean {\n  const vector = boid.p.toPoint(otherBoid.p);\n  if (vector.length() > FLOCK_THRESHOLD) return false;\n\n  const angleDiff = normAngle(vector.angle() - boid.v.angle());\n  return Math.abs(angleDiff) < MAX_ANGLE_DIFF;\n}\n\nfunction normAngle(theta: number) {\n  while (theta > Math.PI) theta -= PI_2;\n  while (theta < -Math.PI) theta += PI_2;\n  return theta;\n}\n\n// Compute change in vector\nfunction computeSteer(boid: Boid, desired: Goal) {\n  if (desired == null) {\n    return new Vector(0, 0);\n  }\n\n  let acceleration: Vector;\n  if (desired.type === GoalType.Point || desired.type === GoalType.Velocity) {\n    let velocity: Vector;\n    if (desired.type === GoalType.Point) {\n      velocity = boid.p.toPoint(desired.goal);\n\n      velocity = velocity.unit().multiply(MAX_SPEED);\n    } else {\n      velocity = desired.goal;\n\n      // Should this be here?\n      velocity = velocity.limit(MAX_SPEED);\n    }\n    acceleration = Vector.sumVectors([velocity, boid.v.multiply(-1)]);\n  } else {\n    acceleration = desired.goal;\n  }\n\n  return acceleration.limit(MAX_ACCEL);\n}\n\nfunction newBoidVector(boid: Boid, state: State): Vector {\n  const flock = state.boids\n    .filter((someBoid) => boid.id !== someBoid.id)\n    .filter((someBoid) => isNeighbor(boid, someBoid));\n\n  let vectors: Vector[] = [\n    computeSteer(boid, stayInBounds(boid)).multiply(2),\n\n    // Use all boids; boids can sense behind them, for proximity\n    computeSteer(boid, maintainDistance(boid, state.boids)).multiply(3),\n\n    // Make boids go slightly faster when possible\n    computeSteer(boid, {\n      type: GoalType.Acceleration,\n      goal: new Vector(MAX_ACCEL / 100, boid.v.theta),\n    }),\n  ];\n\n  const mouse = new Point(state.p5.mouseX, state.p5.mouseY);\n  if (mouse.x > 0 && mouse.x < X_DIM && mouse.y > 0 && mouse.y < Y_DIM) {\n    vectors.push(\n      computeSteer(boid, moveTowardsMouse(mouse, boid)).multiply(-2.4)\n    );\n  }\n\n  if (flock.length > 0) {\n    vectors = [\n      ...vectors,\n      computeSteer(boid, flyToCenterOfFlock(boid, flock)).multiply(0.8),\n      computeSteer(boid, matchVelocity(boid, flock)),\n    ];\n  }\n\n  // Sum vectors\n  return Vector.sumVectors(vectors);\n}\n\nfunction limitMaxTurnSpeed(boid: Boid, newV: Vector): Vector {\n  // Limit max turn speed\n  let dAngle = normAngle(newV.angle() - boid.v.angle());\n  let theta = newV.theta;\n  if (dAngle > MAX_TURN_SPEED) {\n    theta = normAngle(boid.v.angle() + MAX_TURN_SPEED);\n    return new Vector(newV.r, theta);\n  }\n  if (dAngle < -MAX_TURN_SPEED) {\n    theta = normAngle(boid.v.angle() - MAX_TURN_SPEED);\n    return new Vector(newV.r, theta);\n  }\n  return newV;\n}\n\nexport function updateState(state: State): State {\n  return {\n    ...state,\n    boids: state.boids.map((boid) => {\n      const dv = newBoidVector(boid, state);\n      let v = Vector.sumVectors([boid.v, dv]).limit(MAX_SPEED);\n      v = limitMaxTurnSpeed(boid, v);\n\n      let p = boid.p.add(v);\n      p = forceInBounds(p);\n\n      return {\n        ...boid,\n        p,\n        v,\n      };\n    }),\n  };\n}\n\nconst scale = (-SEPARATION_THRESHOLD / 4) * 1.5;\nfunction drawBoid(sketch: p5, boid: Boid) {\n  const theta = boid.v.angle() - sketch.radians(90);\n\n  {\n    sketch.push();\n    sketch.translate(boid.p.x, boid.p.y);\n    sketch.rotate(theta);\n\n    {\n      sketch.beginShape();\n      // Top\n      sketch.vertex(0, -scale);\n      // Left\n      sketch.vertex(-scale / 2, scale);\n      // Right\n      sketch.vertex(scale / 2, scale);\n      sketch.endShape(sketch.CLOSE);\n    }\n    sketch.pop();\n  }\n}\n\nexport function draw(sketch: p5, state: State) {\n  sketch.background(255);\n  sketch.fill(220);\n  sketch.circle(X_DIM / 2, Y_DIM / 2, Math.max(X_DIM, Y_DIM));\n\n  sketch.fill(255, 0, 0);\n  sketch.circle(sketch.mouseX, sketch.mouseY, 4);\n\n  const color = sketch.color(\n    `hsb(${(3 * sketch.frameCount) % 360}, 100%, ${Math.floor(\n      100\n      // (speed / MAX_SPEED) * 100\n    )}%)`\n  );\n  sketch.fill(color);\n  sketch.stroke(64);\n\n  for (const boid of state.boids) {\n    drawBoid(sketch, boid);\n  }\n\n  return state;\n}\n",null,"import p5 from \"p5\";\n\nimport { setup, updateState, draw, State } from \"./sketch\";\n\nnew p5((sketch) => {\n  let state: State;\n\n  sketch.setup = () => {\n    state = setup(sketch);\n    state.p5 = sketch;\n  };\n\n  sketch.draw = () => {\n    state = updateState(state);\n    draw(sketch, state);\n  };\n}, document.getElementById(\"p5canvas\")!);\n"]}