{"mappings":"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","sources":["src/watercolor/index.ts","src/watercolor/sketch.ts"],"names":["_p","require","_sketch","p5","sketch","state","setup","draw","updateState","document","getElementById","createCanvas","X_DIM","Y_DIM","noLoop","translate","background","noStroke","i","colorInfo","COLORS","points","generatePoints","fill","color","push","translateX","translateY","rotate","s","sublayerPoints","j","polygonDeformation","beginShape","point","vertex","x","y","endShape","CLOSE","console","log","pop","newPoints","length","a","c","b","createVector","heading","variance","Math","PI","gaussianShift","randomGaussian","bPerp","shiftedB","Vector","add","mult","window","innerWidth","innerHeight","angle","cos","sin"],"version":3,"file":"watercolor.e9ca7c33.js.map","sourcesContent":["import p5 from \"p5\";\n\nimport { setup, updateState, draw, State } from \"./sketch\";\n\nnew p5((sketch) => {\n  let state: State;\n\n  sketch.setup = () => {\n    state = setup(sketch);\n    state.p5 = sketch;\n  };\n\n  sketch.draw = () => {\n    state = updateState(state);\n    draw(sketch, state);\n  };\n}, document.getElementById(\"p5canvas\")!);\n","import p5 from \"p5\";\n\nexport interface State {\n  p5: p5;\n}\n\n/* Polygon Deformation Technique\n * For each line in the polygon, find the midpoint. Add a new point from a Gaussian distribution centered on that point.\n */\nconst GAUSSIAN_SD = 0.45;\nfunction polygonDeformation(sketch: p5, points: p5.Vector[]): p5.Vector[] {\n  let newPoints = [];\n  for (let i = 0; i < points.length; i++) {\n    // Pick our points, being sure to loop around correctly...\n    const a = points[i];\n    const c = i === points.length - 1 ? points[0] : points[i + 1];\n\n    // The midpoint is a basic average of the two points\n    const b = sketch.createVector((a.x + c.x) / 2, (a.y + c.y) / 2);\n    const heading = b.heading();\n\n    // Dynamic variance based on heading\n    let variance = GAUSSIAN_SD;\n    if (heading > -Math.PI / 4 && heading < Math.PI / 2) {\n      variance += 0.08;\n    } else if (heading > (3 * Math.PI) / 4) {\n      variance -= 0.05;\n    } else if (heading < -Math.PI / 2) {\n      variance += 0.02;\n    }\n\n    const gaussianShift = sketch.randomGaussian(0, variance);\n\n    // Calculate a perpendicular vector\n    let bPerp = sketch.createVector(-(c.y - a.y), c.x - a.x);\n    const shiftedB = p5.Vector.add(b, bPerp.mult(gaussianShift));\n\n    newPoints.push(a);\n    newPoints.push(shiftedB);\n  }\n\n  return newPoints;\n}\n\nconst X_DIM = window.innerWidth;\nconst Y_DIM = window.innerHeight;\n\nconst N_SIDES = 10;\nconst RADIUS = 200;\nconst BASE_DEFORMATIONS = 5;\n\nfunction generatePoints(sketch: p5) {\n  let points: p5.Vector[] = [];\n  for (let i = 0; i < N_SIDES; i++) {\n    const angle = Math.PI * 2 * (i / N_SIDES);\n    points.push(\n      sketch.createVector(RADIUS * Math.cos(angle), RADIUS * Math.sin(angle))\n    );\n  }\n  for (let i = 0; i < BASE_DEFORMATIONS; i++) {\n    points = polygonDeformation(sketch, points);\n  }\n  return points;\n}\n\nexport function setup(sketch: p5): State {\n  sketch.createCanvas(X_DIM, Y_DIM);\n  sketch.noLoop();\n\n  return { p5: sketch };\n}\n\nexport function updateState(state: State): State {\n  return {\n    ...state,\n  };\n}\n\nconst LAYER_COUNT = 45;\nconst LAYER_OPACITY = 0.04;\nconst LAYER_DEFORMATIONS = 6;\n\ninterface Color {\n  color: string;\n  points?: p5.Vector[];\n  translateX?: number;\n  translateY?: number;\n  rotate?: number;\n}\n\nconst SUBLAYER_COUNT = 5;\nconst COLORS: Color[] = [\n  {\n    color: `rgba(255, 186, 186, ${LAYER_OPACITY})`,\n    translateX: -100,\n    translateY: -100,\n    rotate: Math.PI / 2,\n  },\n  {\n    color: `rgba(253, 226, 226, ${LAYER_OPACITY})`,\n    translateX: 100,\n    translateY: -100,\n    rotate: -Math.PI / 2,\n  },\n  {\n    color: `rgba(170, 207, 207, ${LAYER_OPACITY})`,\n    translateX: -100,\n    translateY: 100,\n    rotate: Math.PI,\n  },\n  {\n    color: `rgba(103, 155, 155, ${LAYER_OPACITY})`,\n    translateX: 100,\n    translateY: 100,\n    rotate: 0,\n  },\n];\n\nexport function draw(sketch: p5, state: State) {\n  // Move center to 0, 0\n  sketch.translate(X_DIM / 2, Y_DIM / 2);\n  sketch.background(223, 214, 189);\n\n  sketch.noStroke();\n\n  for (let i = 0; i < LAYER_COUNT; i += SUBLAYER_COUNT) {\n    for (const colorInfo of COLORS) {\n      const points = (colorInfo.points =\n        colorInfo.points || generatePoints(sketch));\n\n      sketch.fill(colorInfo.color);\n\n      sketch.push();\n      if (colorInfo.translateX && colorInfo.translateY) {\n        sketch.translate(colorInfo.translateX, colorInfo.translateY);\n      }\n      if (colorInfo.rotate) {\n        sketch.rotate(colorInfo.rotate);\n      }\n\n      for (let s = 0; s < SUBLAYER_COUNT; s++) {\n        let sublayerPoints = points;\n        for (let j = 0; j < LAYER_DEFORMATIONS; j++) {\n          sublayerPoints = polygonDeformation(sketch, points);\n        }\n        sketch.beginShape();\n        for (const point of sublayerPoints) {\n          sketch.vertex(point.x, point.y);\n        }\n        sketch.endShape(sketch.CLOSE);\n\n        console.log(i, colorInfo, s);\n      }\n      sketch.pop();\n    }\n  }\n\n  return state;\n}\n"]}